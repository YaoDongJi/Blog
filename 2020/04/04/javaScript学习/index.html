<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="比较运算符 第一种是&#x3D;&#x3D;比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是&#x3D;&#x3D;&#x3D;比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。由于JavaScript这个设计缺陷，不要使用&#x3D;&#x3D;比较，始终坚持使用&#x3D;&#x3D;&#x3D;比较。  NaN这个特殊的Number与所有其他值都不相等，包括它自己，唯一能判断NaN的方法是通过isNaN()函数    对象 Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="javaScript学习">
<meta property="og:url" content="http://yoursite.com/2020/04/04/javaScript%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Blog of YaoDongJi">
<meta property="og:description" content="比较运算符 第一种是&#x3D;&#x3D;比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是&#x3D;&#x3D;&#x3D;比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。由于JavaScript这个设计缺陷，不要使用&#x3D;&#x3D;比较，始终坚持使用&#x3D;&#x3D;&#x3D;比较。  NaN这个特殊的Number与所有其他值都不相等，包括它自己，唯一能判断NaN的方法是通过isNaN()函数    对象 Jav">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/images/pasted-33.png">
<meta property="article:published_time" content="2020-04-04T01:22:11.000Z">
<meta property="article:modified_time" content="2020-04-07T08:20:58.675Z">
<meta property="article:author" content="YaoDongJi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/pasted-33.png">

<link rel="canonical" href="http://yoursite.com/2020/04/04/javaScript%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>javaScript学习 | Blog of YaoDongJi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of YaoDongJi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/javaScript%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YaoDongJi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of YaoDongJi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javaScript学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-04 09:22:11" itemprop="dateCreated datePublished" datetime="2020-04-04T09:22:11+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-07 16:20:58" itemprop="dateModified" datetime="2020-04-07T16:20:58+08:00">2020-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol>
<li><p>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。</p>
</li>
<li><p>NaN这个特殊的Number与所有其他值都不相等，包括它自己，唯一能判断NaN的方法是通过isNaN()函数</p>
</li>
<li></li>
</ol>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ol>
<li><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</span><br><span class="line">    city: <span class="string">'Beijing'</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">xiaoming.age &#x3D; 18; &#x2F;&#x2F; 新增一个age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; 18</span><br><span class="line">delete xiaoming.age; &#x2F;&#x2F; 删除age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming[&#39;name&#39;]; &#x2F;&#x2F; 删除name属性</span><br><span class="line">xiaoming.name; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F; 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure></li>
<li><p>for … of循环和for … in循环有何区别？<br>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
</li>
</ol>
<h3 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h3><ol>
<li><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p>
</li>
<li><p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight plain"><figcaption><span>strict';```   </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 多行字符串</span><br><span class="line">1. 由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号&#96;&#96; 表示</span><br><span class="line">2. 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：  </span><br><span class="line">3. JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串</span><br><span class="line"></span><br><span class="line">### 函数</span><br><span class="line">1. 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined</span><br><span class="line">2. 由于JavaScript的函数也是一个对象</span><br></pre></td></tr></table></figure>
<p>var abs = function (x) {<br> if (x &gt;= 0) {</p>
<pre><code>return x;</code></pre><p> } else {</p>
<pre><code>return -x;</code></pre><p> }<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3. 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</span><br><span class="line">4. JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 变量作用域</span><br><span class="line"></span><br><span class="line">1. 变量提升 JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</span><br><span class="line">2. **不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：**  </span><br><span class="line">由于函数定义有两种方式，以变量方式var foo &#x3D; function () &#123;&#125;定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：  </span><br><span class="line">3. 名字空间： 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。  </span><br><span class="line">减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如</span><br></pre></td></tr></table></figure>
<p>// 唯一的全局变量MYAPP:<br>var MYAPP = {};</p>
<p>// 其他变量:<br>MYAPP.name = ‘myapp’;<br>MYAPP.version = 1.0;</p>
<p>// 其他函数:<br>MYAPP.foo = function () {<br>   return ‘foo’;<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. 局部作用域  </span><br><span class="line">由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：</span><br></pre></td></tr></table></figure>
<p>‘use strict’;</p>
<p>function foo() {<br>   for (var i=0; i&lt;100; i++) {</p>
<pre><code>//</code></pre><p>   }<br>   i += 100; // 仍然可以引用变量i<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</span><br></pre></td></tr></table></figure>
<p>‘use strict’;<br>function foo() {<br>   var sum = 0;<br>   for (let i=0; i&lt;100; i++) {</p>
<pre><code>sum += i;</code></pre><p>   }<br>   // SyntaxError:<br>   i += 1;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 装饰器</span><br><span class="line">利用apply()，我们还可以动态改变函数的行为。</span><br><span class="line"></span><br><span class="line">JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</span><br><span class="line"></span><br><span class="line">现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count +&#x3D; 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</span><br></pre></td></tr></table></figure>
<p>use strict’;</p>
</li>
</ol>
<p>var count = 0;<br>var oldParseInt = parseInt; // 保存原函数</p>
<p>window.parseInt = function () {<br>    count += 1;<br>    return oldParseInt.apply(null, arguments); // 调用原函数<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 高阶函数</span><br><span class="line">1. map&#x2F;reduce</span><br><span class="line"></span><br><span class="line">![upload successful](&#x2F;images&#x2F;pasted-29.png)</span><br></pre></td></tr></table></figure>
<p>‘use strict’;</p>
<p>function pow(x) {<br>    return x * x;<br>}<br>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br>var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]<br>console.log(results);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**注意：map()传入的参数是pow，即函数对象本身。**  </span><br><span class="line"></span><br><span class="line">Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：&#96;&#96;&#96;[x1, x2, x3, x4].reduce(f) &#x3D; f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<p>比方说对一个Array求和，就可以用reduce实现：</p>
<figure class="highlight plain"><figcaption><span>arr </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;); &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>filter<br>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。</li>
</ol>
<p>和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">var r &#x3D; arr.filter(function (x) &#123;</span><br><span class="line">    return x % 2 !&#x3D;&#x3D; 0;</span><br><span class="line">&#125;);</span><br><span class="line">r; &#x2F;&#x2F; [1, 5, 9, 15]</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol>
<li>函数作为返回值<br>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum &#x3D; function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：  <figure class="highlight plain"><figcaption><span>f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用函数f时，才真正计算求和的结果：&#96;&#96;&#96;f(); &#x2F;&#x2F; 15&#96;&#96;&#96;  </span><br><span class="line">我们在函数lazy_sum中又定义了函数sum，并且，**内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中**，这种称为“闭包（Closure）”的程序结构拥有极大的威力。  </span><br><span class="line">请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</span><br></pre></td></tr></table></figure>
var f1 = lazy_sum([1, 2, 3, 4, 5]);<br>var f2 = lazy_sum([1, 2, 3, 4, 5]);<br>f1 === f2; // false<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**</span><br><span class="line">### generator</span><br><span class="line">generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。  </span><br><span class="line">generator跟函数很像，定义如下：</span><br></pre></td></tr></table></figure>
function* foo(x) {<br> yield x + 1;<br> yield x + 2;<br> return x + 3;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要编写一个产生斐波那契数列的函数，可以这么写：</span><br></pre></td></tr></table></figure>
function fib(max) {<br> var<pre><code>t,
a = 0,
b = 1,
arr = [0, 1];</code></pre> while (arr.length &lt; max) {<pre><code>[a, b] = [b, a + b];
arr.push(b);</code></pre> }<br> return arr;<br>}</li>
</ol>
<p>// 测试:<br>fib(5); // [0, 1, 1, 2, 3]<br>fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：</span><br></pre></td></tr></table></figure>
<p>function* fib(max) {<br>    var<br>        t,<br>        a = 0,<br>        b = 1,<br>        n = 0;<br>    while (n &lt; max) {<br>        yield a;<br>        [a, b] = [b, a + b];<br>        n ++;<br>    }<br>    return;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">直接调用试试：  </span><br><span class="line">&#96;&#96;&#96;fib(5); &#x2F;&#x2F; fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;&#96;&#96;&#96;  </span><br><span class="line">直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</span><br><span class="line"></span><br><span class="line">调用generator对象有两个方法，一是不断地调用generator对象的next()方法：</span><br></pre></td></tr></table></figure>
<p>var f = fib(5);<br>f.next(); // {value: 0, done: false}<br>f.next(); // {value: 1, done: false}<br>f.next(); // {value: 1, done: false}<br>f.next(); // {value: 2, done: false}<br>f.next(); // {value: 3, done: false}<br>f.next(); // {value: undefined, done: true}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象&#123;value: x, done: true&#x2F;false&#125;，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。</span><br><span class="line"></span><br><span class="line">当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。</span><br><span class="line"></span><br><span class="line">第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：</span><br></pre></td></tr></table></figure>
<p>for (var x of fib(10)) {<br>    console.log(x); // 依次输出0, 1, 1, 2, 3, …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">### 正则表达式</span><br><span class="line">1. 分组  </span><br><span class="line">除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：</span><br><span class="line"></span><br><span class="line">^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：  </span><br><span class="line">&#96;&#96;&#96;var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line">re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line">re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null&#96;&#96;&#96;  </span><br><span class="line">如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。</span><br><span class="line"></span><br><span class="line">exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</span><br><span class="line"></span><br><span class="line">exec()方法在匹配失败时返回null。  </span><br><span class="line">2. 全局匹配  </span><br><span class="line">JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：  </span><br><span class="line">&#96;&#96;&#96;var r1 &#x3D; &#x2F;test&#x2F;g;</span><br><span class="line">&#x2F;&#x2F; 等价于:</span><br><span class="line">var r2 &#x3D; new RegExp(&#39;test&#39;, &#39;g&#39;);&#96;&#96;&#96;  </span><br><span class="line">全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：</span><br></pre></td></tr></table></figure>
<p>var s = ‘JavaScript, VBScript, JScript and ECMAScript’;<br>var re=/[a-zA-Z]+Script/g;</p>
<p>// 使用全局匹配:<br>re.exec(s); // [‘JavaScript’]<br>re.lastIndex; // 10</p>
<p>re.exec(s); // [‘VBScript’]<br>re.lastIndex; // 20</p>
<p>re.exec(s); // [‘JScript’]<br>re.lastIndex; // 29</p>
<p>re.exec(s); // [‘ECMAScript’]<br>re.lastIndex; // 44</p>
<p>re.exec(s); // null，直到结束仍没有匹配到``` </p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ol>
<li><p>序列化<br>在JSON中，一共就这么几种数据类型：</p>
<ul>
<li>number：和JavaScript的number完全一致；  </li>
<li>boolean：就是JavaScript的true或false；</li>
<li>string：就是JavaScript的string；</li>
<li>null：就是JavaScript的null；</li>
<li>array：就是JavaScript的Array表示方式——[]；</li>
<li>object：就是JavaScript的{ … }表示方式。  </li>
</ul>
<p>JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">  var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;,</span><br><span class="line">    age: 14,</span><br><span class="line">    gender: true,</span><br><span class="line">    height: 1.65,</span><br><span class="line">    grade: null,</span><br><span class="line">    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,</span><br><span class="line">    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]</span><br><span class="line">&#125;;</span><br><span class="line">var s &#x3D; JSON.stringify(xiaoming);</span><br><span class="line">console.log(s);</span><br><span class="line"></span><br><span class="line">  输出：</span><br><span class="line">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>要输出得好看一些，可以加上参数，按缩进输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(xiaoming, null, &#39;  &#39;);</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"> &quot;name&quot;: &quot;小明&quot;,</span><br><span class="line"> &quot;age&quot;: 14,</span><br><span class="line"> &quot;gender&quot;: true,</span><br><span class="line"> &quot;height&quot;: 1.65,</span><br><span class="line"> &quot;grade&quot;: null,</span><br><span class="line"> &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; Middle School&quot;,</span><br><span class="line"> &quot;skills&quot;: [</span><br><span class="line">   &quot;JavaScript&quot;,</span><br><span class="line">   &quot;Java&quot;,</span><br><span class="line">   &quot;Python&quot;,</span><br><span class="line">   &quot;Lisp&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理： </p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   function convert(key, value) &#123;</span><br><span class="line">    if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        return value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(xiaoming, convert, &#39;  &#39;);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;小明&quot;,</span><br><span class="line">  &quot;age&quot;: 14,</span><br><span class="line">  &quot;gender&quot;: true,</span><br><span class="line">  &quot;height&quot;: 1.65,</span><br><span class="line">  &quot;grade&quot;: null,</span><br><span class="line">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; MIDDLE SCHOOL&quot;,</span><br><span class="line">  &quot;skills&quot;: [</span><br><span class="line">    &quot;JAVASCRIPT&quot;,</span><br><span class="line">    &quot;JAVA&quot;,</span><br><span class="line">    &quot;PYTHON&quot;,</span><br><span class="line">    &quot;LISP&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;,</span><br><span class="line">    age: 14,</span><br><span class="line">    gender: true,</span><br><span class="line">    height: 1.65,</span><br><span class="line">    grade: null,</span><br><span class="line">    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,</span><br><span class="line">    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;],</span><br><span class="line">    toJSON: function () &#123;</span><br><span class="line">        return &#123; &#x2F;&#x2F; 只输出name和age，并且改变了key：</span><br><span class="line">            &#39;Name&#39;: this.name,</span><br><span class="line">            &#39;Age&#39;: this.age</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(xiaoming); &#x2F;&#x2F; &#39;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#39;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>反序列化<br>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&#39;[1,2,3,true]&#39;); &#x2F;&#x2F; [1, 2, 3, true]</span><br><span class="line">JSON.parse(&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#39;); &#x2F;&#x2F; Object &#123;name: &#39;小明&#39;, age: 14&#125;</span><br><span class="line">JSON.parse(&#39;true&#39;); &#x2F;&#x2F; true</span><br><span class="line">JSON.parse(&#39;123.45&#39;); &#x2F;&#x2F; 123.45&#96;&#96;&#96;  </span><br><span class="line">JSON.parse()还可以接收一个函数，用来转换解析出的属性：</span><br></pre></td></tr></table></figure>
var obj = JSON.parse(‘{“name”:”小明”,”age”:14}’, function (key, value) {<br> if (key === ‘name’) {<pre><code>return value + &apos;同学&apos;;</code></pre> }<br> return value;<br>});<br>console.log(JSON.stringify(obj)); // {name: ‘小明同学’, age: 14}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 面向对象编程  </span><br><span class="line">1. JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</span><br></pre></td></tr></table></figure>
var Student = {<br> name: ‘Robot’,<br> height: 1.2,<br> run: function () {<pre><code>console.log(this.name + &apos; is running...&apos;);</code></pre> }<br>};</li>
</ol>
<p>var xiaoming = {<br>    name: ‘小明’<br>};</p>
<p>xiaoming.<strong>proto</strong> = Student;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：  </span><br><span class="line">&#96;&#96;&#96;xiaoming.name; &#x2F;&#x2F; &#39;小明&#39;</span><br><span class="line">xiaoming.run(); &#x2F;&#x2F; 小明 is running...&#96;&#96;&#96;  </span><br><span class="line">JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</span><br><span class="line">如果你把xiaoming的原型指向其他对象：</span><br><span class="line"></span><br><span class="line">请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</span><br></pre></td></tr></table></figure>
<p>// 原型对象:<br>var Student = {<br>    name: ‘Robot’,<br>    height: 1.2,<br>    run: function () {<br>        console.log(this.name + ‘ is running…’);<br>    }<br>};</p>
<p>function createStudent(name) {<br>    // 基于Student原型创建一个新对象:<br>    var s = Object.create(Student);<br>    // 初始化新对象:<br>    s.name = name;<br>    return s;<br>}</p>
<p>var xiaoming = createStudent(‘小明’);<br>xiaoming.run(); // 小明 is running…<br>xiaoming.<strong>proto</strong> === Student; // true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">### 浏览器对象</span><br><span class="line">1. window  </span><br><span class="line">window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。</span><br><span class="line">2. navigator  </span><br><span class="line">navigator对象表示浏览器的信息，最常用的属性包括：</span><br><span class="line">  + navigator.appName：浏览器名称；</span><br><span class="line">  + navigator.appVersion：浏览器版本；</span><br><span class="line">  + navigator.language：浏览器设置的语言；</span><br><span class="line">  + navigator.platform：操作系统类型；</span><br><span class="line">  + navigator.userAgent：浏览器设定的User-Agent字符串。</span><br><span class="line">3. location</span><br><span class="line">location对象表示当前页面的URL信息。例如，一个完整的URL： </span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;javaScript</span><br><span class="line">http:&#x2F;&#x2F;www.example.com:8080&#x2F;path&#x2F;index.html?a&#x3D;1&amp;b&#x3D;2#TOP</span><br><span class="line">    &#96;&#96;&#96;  </span><br><span class="line">    </span><br><span class="line"> 可以用location.href获取。要获得URL各个部分的值，可以这么写</span><br></pre></td></tr></table></figure>
<p>  location.protocol; // ‘http’<br>location.host; // ‘<a href="http://www.example.com&#39;" target="_blank" rel="noopener">www.example.com&#39;</a><br>location.port; // ‘8080’<br>location.pathname; // ‘/path/index.html’<br>location.search; // ‘?a=1&amp;b=2’<br>location.hash; // ‘TOP’```<br>要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。<br>4. document<br>  document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p>
<p>  document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：</p>
<p>  要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dl id&#x3D;&quot;drink-menu&quot; style&#x3D;&quot;border:solid 1px #ccc;padding:6px;&quot;&gt;</span><br><span class="line">    &lt;dt&gt;摩卡&lt;&#x2F;dt&gt;</span><br><span class="line">    &lt;dd&gt;热摩卡咖啡&lt;&#x2F;dd&gt;</span><br><span class="line">    &lt;dt&gt;酸奶&lt;&#x2F;dt&gt;</span><br><span class="line">    &lt;dd&gt;北京老酸奶&lt;&#x2F;dd&gt;</span><br><span class="line">    &lt;dt&gt;果汁&lt;&#x2F;dt&gt;</span><br><span class="line">    &lt;dd&gt;鲜榨苹果汁&lt;&#x2F;dd&gt;</span><br><span class="line">&lt;&#x2F;dl&gt;</span><br></pre></td></tr></table></figure><br>  用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'drink-menu'</span>);</span><br><span class="line">  <span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'dt'</span>);</span><br><span class="line">  <span class="keyword">var</span> i, s;</span><br><span class="line"></span><br><span class="line">  s = <span class="string">'提供的饮料有:'</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">      s = s + drinks[i].innerHTML + <span class="string">','</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">  document对象还有一个cookie属性，可以获取当前页面的Cookie。</span></span><br><span class="line"><span class="string">  Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</span></span><br><span class="line"><span class="string">### AJAX</span></span><br><span class="line"><span class="string">AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 这就是Web的运作原理：一次HTTP请求对应一个页面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。  </span></span><br><span class="line"><span class="string"> **用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。**  </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：</span></span><br><span class="line"><span class="string"> `</span><span class="string">``</span>javaScript</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-  text'</span>);</span><br><span class="line">      textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数    被回调</span></span><br><span class="line">      <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送请求:</span></span><br><span class="line">  request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">  request.send();</span><br><span class="line"></span><br><span class="line">  alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><br>  通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。</p>
<p> 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。</p>
<p> XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。</p>
<p> 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</p>
<p> 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。</p>
<h4 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h4><p> 上面代码的URL使用的是相对路径。 如果你把它改为’<a href="http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。" target="_blank" rel="noopener">http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</a></p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：</p>
<p>一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<p>二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器： <code>&#39;/proxy?url=http://www.sina.com.cn&#39;</code>  </p>
<p> 代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<p>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：<br>以163的股票查询URL为例，对于URL：<a href="http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回：" target="_blank" rel="noopener">http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回：</a>  </p>
<figure class="highlight plain"><figcaption><span>"0000001", ... &#125;);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">因此我们需要首先在页面中准备好回调函数：  </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;function refreshPrice(data) &#123;</span><br><span class="line">    var p &#x3D; document.getElementById(&#39;test-jsonp&#39;);</span><br><span class="line">    p.innerHTML &#x3D; &#39;当前价格：&#39; +</span><br><span class="line">        data[&#39;0000001&#39;].name +&#39;: &#39; + </span><br><span class="line">        data[&#39;0000001&#39;].price + &#39;；&#39; +</span><br><span class="line">        data[&#39;1399001&#39;].name + &#39;: &#39; +</span><br><span class="line">        data[&#39;1399001&#39;].price;</span><br><span class="line">&#125;&#96;&#96;&#96;  </span><br><span class="line">最后用getPrice()函数触发：  </span><br><span class="line">&#96;&#96;&#96;function getPrice() &#123;</span><br><span class="line">    var</span><br><span class="line">        js &#x3D; document.createElement(&#39;script&#39;),</span><br><span class="line">        head &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class="line">    js.src &#x3D; &#39;http:&#x2F;&#x2F;api.money.126.net&#x2F;data&#x2F;feed&#x2F;0000001,1399001?callback&#x3D;refreshPrice&#39;;</span><br><span class="line">    head.appendChild(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>了解CORS前，我们先搞明白概念：</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>用一个图来表示就是：<br><img src="/images/pasted-33.png" alt="upload successful"></p>
<h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><ol>
<li><p>使用jQuery只需要在页面的<head>引入jQuery文件即可：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;&#x2F;code.jquery.com&#x2F;jquery-1.11.3.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>$是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：  </p>
<p>绝大多数时候，我们都直接用$（因为写起来更简单嘛）。但是，如果$这个变量不幸地被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量：  </p>
<figure class="highlight plain"><figcaption><span>// jQuery(selector, context)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line">$; &#x2F;&#x2F; undefined</span><br><span class="line">jQuery; &#x2F;&#x2F; jQuery(selector, context)</span><br></pre></td></tr></table></figure></li>
<li><p>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/31/truffle%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" rel="prev" title="truffle框架学习">
      <i class="fa fa-chevron-left"></i> truffle框架学习
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#比较运算符"><span class="nav-number">1.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">2.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strict模式"><span class="nav-number">3.</span> <span class="nav-text">strict模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON"><span class="nav-number">5.</span> <span class="nav-text">JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安全限制"><span class="nav-number">5.1.</span> <span class="nav-text">安全限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS"><span class="nav-number">5.2.</span> <span class="nav-text">CORS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JQuery"><span class="nav-number">6.</span> <span class="nav-text">JQuery</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YaoDongJi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YaoDongJi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
